---
sidebar_position: 4
description: 'Middlewares, Chaining'
---

# Middlewares

 - Middlewares are a way to reuse code.  
 - They can pass data down to other middlewares.  
 - They can also prevent further execution.  
 - They can send responses so you don't have to handle every case.

NOTE: Schema validators are also middlewares.

## Basic

```ts
builder
  .middleware(async () => {
    const randomValue = Math.random();
    if (randomValue > 0.5) return { next: true, randomValue };
    return { next: false, statusCode: 500, message: "Unlucky" };
  })
  .get(async ({ data }) => {
    return success({
      message: `You won with ${data.randomValue}`,
    });
  });
```

 - If the middleware returns `{ next: true }`, it can also add something to `data` type-safely.
    - The above example returns `{ next: true, randomValue }` thus `data.randomValue` is accessible in the next request handler.
 - If the middleware returns `{ next: false }` it sends a response thus it needs `statusCode`. 
 But having `result` is also advised for a good **discriminated union**.

## Middleware Chaining

Some middlewares need to use schema validation.
This, however, prevents you to just move the request handler out of the request handler building.
To solve this, there are two concepts you can use:
    - `.buildLink()` Instead of the final middleware, you can use this to get a chain link.
    - `.chain(fooLink).chain(barLink)` to bring multiple links into the request handler building.

Here's an example:

```ts
const authLink = builder
  .headersSchema(
    z.object({
      authorization: z.string(),
    })
  )
  .middleware(async ({ data }) => {
    if (data.headers.authorization === "foo")
      return {
        next: true,
      };
    return {
      next: false,
      statusCode: 401 as const,
    };
  })
  .buildLink();

const routes = {
  getAuthedWelcomeMessage: builder
    .chain(authLink)
    .get(async () => {
        return success({ message: "hi" });
    }),
};
```
